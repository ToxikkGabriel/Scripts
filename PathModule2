--[[
-------------------------------------------------------------------
SIMPLEPATH MODIFICADO PARA BODYVELOCITY (CUSTOM MOVEMENT)
Modifica√ß√µes feitas para integra√ß√£o com script de Voo/Andar via BV.
---------------------------------------------------------------------
]]

local DEFAULT_SETTINGS = {
	TIME_VARIANCE = 0.07;
	COMPARISON_CHECKS = 1;
	JUMP_WHEN_STUCK = true;
}

---------------------------------------------------------------------

local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService") -- üî• Necess√°rio para o loop customizado

local function output(func, msg)
	func(((func == error and "SimplePath Error: ") or "SimplePath: ")..msg)
end

local Path = {
	StatusType = {
		Idle = "Idle";
		Active = "Active";
	};
	ErrorType = {
		LimitReached = "LimitReached";
		TargetUnreachable = "TargetUnreachable";
		ComputationError = "ComputationError";
		AgentStuck = "AgentStuck";
	};
}

Path.__index = function(table, index)
	if index == "Stopped" and not table._humanoid then
		output(error, "Attempt to use Path.Stopped on a non-humanoid.")
	end
	return (table._events[index] and table._events[index].Event)
		or (index == "LastError" and table._lastError)
		or (index == "Status" and table._status)
		or Path[index]
end

-- Visualiza√ß√£o (Mantida igual)
local visualWaypoint = Instance.new("Part")
visualWaypoint.Size = Vector3.new(0.3, 0.3, 0.3)
visualWaypoint.Anchored = true
visualWaypoint.CanCollide = false
visualWaypoint.Material = Enum.Material.Neon
visualWaypoint.Shape = Enum.PartType.Ball

local function declareError(self, errorType)
	self._lastError = errorType
	self._events.Error:Fire(errorType)
end

local function createVisualWaypoints(waypoints)
	local visualWaypoints = {}
	for _, waypoint in ipairs(waypoints) do
		local visualWaypointClone = visualWaypoint:Clone()
		visualWaypointClone.Position = waypoint.Position
		visualWaypointClone.Parent = workspace
		visualWaypointClone.Color =
			(waypoint == waypoints[#waypoints] and Color3.fromRGB(0, 255, 0))
			or (waypoint.Action == Enum.PathWaypointAction.Jump and Color3.fromRGB(255, 0, 0))
			or Color3.fromRGB(255, 139, 0)
		table.insert(visualWaypoints, visualWaypointClone)
	end
	return visualWaypoints
end

local function destroyVisualWaypoints(waypoints)
	if waypoints then
		for _, waypoint in ipairs(waypoints) do
			waypoint:Destroy()
		end
	end
	return
end

-- üî• FUN√á√ÉO DE PULO (Mantida, mas depende da f√≠sica do jogo)
local function setJumpState(self)
	pcall(function()
		if self._humanoid then
			self._humanoid.Jump = true
		end
	end)
end

-- üî• FUN√á√ÉO QUE CONTROLA O MOVIMENTO A CADA FRAME
-- Substitui o MoveToFinished nativo
local function customMoveLoop(self)
	if not self._status == Path.StatusType.Active then return end
	
	-- Pega o alvo atual (Waypoint)
	local targetWaypoint = self._waypoints[self._currentWaypoint]
	if not targetWaypoint then return end
	
	local currentPos = self._agent.PrimaryPart.Position
	local targetPos = targetWaypoint.Position
	
	-- Ajusta altura do alvo para a altura do p√© do bot (evita tentar entrar no ch√£o)
	local moveTarget = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
	
	-- Calcula dist√¢ncia
	local distance = (Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Magnitude
	
	-- 1. APLICA VELOCIDADE NO BV
	if self._bv then
		local dir = (moveTarget - currentPos).Unit
		-- Se for pular, mantemos o Y solto ou usamos l√≥gica de pulo
		if targetWaypoint.Action == Enum.PathWaypointAction.Jump then
			setJumpState(self)
		end
		
		-- Aplica velocidade (Mantendo Y zerado no BV para andar no ch√£o, ou controlado externamente)
		-- Aqui assumimos que o script principal configura o MaxForce.Y.
		-- N√≥s apenas damos a dire√ß√£o X/Z.
		self._bv.Velocity = dir * self._speed
	end

	-- 2. VERIFICA SE CHEGOU (MoveToFinished manual)
	if distance < 3.5 then -- üî• Toler√¢ncia de chegada (3.5 studs)
		-- Chama a fun√ß√£o de finaliza√ß√£o passando "true" (chegou)
		self:_moveToFinished(true)
	end
end

-- Desconecta o loop de movimento
local function disconnectMoveConnection(self)
	if self._moveConnection then
		self._moveConnection:Disconnect()
		self._moveConnection = nil
	end
	-- Zera velocidade ao parar
	if self._bv then
		self._bv.Velocity = Vector3.new(0,0,0)
	end
end

local function invokeWaypointReached(self)
	local lastWaypoint = self._waypoints[self._currentWaypoint - 1]
	local nextWaypoint = self._waypoints[self._currentWaypoint]
	self._events.WaypointReached:Fire(self._agent, lastWaypoint, nextWaypoint)
end

-- Fun√ß√£o interna renomeada para ser chamada pelo nosso loop
function Path:_moveToFinished(reached)
	--Stop execution if Path is destroyed
	if not getmetatable(self) then return end

	if reached and self._currentWaypoint + 1 <= #self._waypoints  then --Waypoint reached
		if self._currentWaypoint + 1 < #self._waypoints then
			invokeWaypointReached(self)
		end
		self._currentWaypoint += 1
		-- N√£o precisamos chamar move() aqui, o loop cuida do proximo waypoint automaticamente
	elseif reached then --Target reached, pathfinding ends
		disconnectMoveConnection(self)
		self._status = Path.StatusType.Idle
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		self._events.Reached:Fire(self._agent, self._waypoints[self._currentWaypoint])
	else --Target unreachable
		disconnectMoveConnection(self)
		self._status = Path.StatusType.Idle
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		declareError(self, self.ErrorType.TargetUnreachable)
	end
end

local function comparePosition(self)
	if self._currentWaypoint == #self._waypoints then return end
	self._position._count = ((self._agent.PrimaryPart.Position - self._position._last).Magnitude <= 0.07 and (self._position._count + 1)) or 0
	self._position._last = self._agent.PrimaryPart.Position
	
	-- Se travou
	if self._position._count >= self._settings.COMPARISON_CHECKS then
		if self._settings.JUMP_WHEN_STUCK then
			setJumpState(self)
		end
		-- Opcional: Declarar erro ou tentar recalcular
		-- declareError(self, self.ErrorType.AgentStuck)
	end
end

--[[ CONSTRUCTOR ]]--
-- üî• MODIFICADO: Aceita bodyVelocity e speed
function Path.new(agent, agentParameters, bodyVelocity, speed, override)
	if not (agent and agent:IsA("Model") and agent.PrimaryPart) then
		output(error, "Pathfinding agent must be a valid Model Instance with a set PrimaryPart.")
	end

	local self = setmetatable({
		_settings = override or DEFAULT_SETTINGS;
		_events = {
			Reached = Instance.new("BindableEvent");
			WaypointReached = Instance.new("BindableEvent");
			Blocked = Instance.new("BindableEvent");
			Error = Instance.new("BindableEvent");
			Stopped = Instance.new("BindableEvent");
		};
		_agent = agent;
		_humanoid = agent:FindFirstChildOfClass("Humanoid");
		_path = PathfindingService:CreatePath(agentParameters);
		_status = "Idle";
		_t = 0;
		_position = {
			_last = Vector3.new();
			_count = 0;
		};
		-- üî• Novos par√¢metros
		_bv = bodyVelocity;
		_speed = speed or 16;
	}, Path)

	--Configure settings
	for setting, value in pairs(DEFAULT_SETTINGS) do
		self._settings[setting] = self._settings[setting] == nil and value or self._settings[setting]
	end

	--Path blocked connection
	self._path.Blocked:Connect(function(...)
		if (self._currentWaypoint <= ... and self._currentWaypoint + 1 >= ...) then
			setJumpState(self)
			self._events.Blocked:Fire(self._agent, self._waypoints[...])
		end
	end)

	return self
end

--[[ NON-STATIC METHODS ]]--
function Path:Destroy()
	disconnectMoveConnection(self) -- Garante que o loop pare
	for _, event in ipairs(self._events) do
		event:Destroy()
	end
	self._events = nil
	if rawget(self, "_visualWaypoints") then
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
	end
	self._path:Destroy()
	setmetatable(self, nil)
	for k, _ in pairs(self) do
		self[k] = nil
	end
end

function Path:Stop()
	if self._status == Path.StatusType.Idle then
		return
	end
	disconnectMoveConnection(self)
	self._status = Path.StatusType.Idle
	self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
	self._events.Stopped:Fire(self._model)
end

function Path:Run(target)
	--Parameter check
	if not (target and (typeof(target) == "Vector3" or target:IsA("BasePart"))) then
		output(error, "Pathfinding target must be a valid Vector3 or BasePart.")
	end

	--Refer to Settings.TIME_VARIANCE
	if os.clock() - self._t <= self._settings.TIME_VARIANCE then
		task.wait(os.clock() - self._t)
		declareError(self, self.ErrorType.LimitReached)
		return false
	else
		self._t = os.clock()
	end

	--Compute path
	local targetPos = (typeof(target) == "Vector3" and target) or target.Position
	local pathComputed, _ = pcall(function()
		self._path:ComputeAsync(self._agent.PrimaryPart.Position, targetPos)
	end)

	if not pathComputed or self._path.Status == Enum.PathStatus.NoPath or #self._path:GetWaypoints() < 2 then
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		task.wait()
		declareError(self, self.ErrorType.ComputationError)
		return false
	end

	--Set status to active
	self._status = Path.StatusType.Active
	self._target = target

	--Initialize waypoints
	self._waypoints = self._path:GetWaypoints()
	self._currentWaypoint = 3

	--Visualize
	destroyVisualWaypoints(self._visualWaypoints)
	self._visualWaypoints = (self.Visualize and createVisualWaypoints(self._waypoints))

	-- üî• CONEX√ÉO DO LOOP CUSTOMIZADO
	-- Em vez de MoveToFinished, usamos Heartbeat para controlar o BV e checar chegada
	disconnectMoveConnection(self) -- Limpa anterior se houver
	self._moveConnection = RunService.Heartbeat:Connect(function()
		customMoveLoop(self)
		if self._settings.COMPARISON_CHECKS > 0 then
			comparePosition(self)
		end
	end)

	return true
end

return Path
